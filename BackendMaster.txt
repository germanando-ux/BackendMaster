POSTGRESQL 
Puerto 5432
usuario admin
password password123

REDIS
nuget Microsoft.Extensions.Caching.StackExchangeRedis

entrar en el contenedor:
docker exec -it backend_course_redis redis-cli

"RedisConnection": "localhost:6379"
IDE Redis Insight

DOKER
--Levantar im√°genes (En el directorio donde este el yaml)
		docker compose up -d

POSTGRESQL 
    "PostgresConnection": "Host=localhost;Port=5432;Database=MyStoreDb;Username=admin;Password=password123",
	
RABBITMQ 

nuget: MassTransit.RabbitMQ

http://localhost:15672

Usa el usuario guest y contrase√±a guest.	
			
		
KIBANA
nuget Elastic.NLog.Targets

http://localhost:5601		

Teor√≠a: Elasticsearch guarda los datos en √çndices (que son como tablas de una base de datos pero optimizadas para texto). NLog crea un √≠ndice nuevo cada d√≠a (ej: store-logs-2026-01-13). Si Kibana tuviera que apuntar a cada tabla individualmente, ser√≠a una locura. Una Data View es un patr√≥n que agrupa muchos √≠ndices bajo un solo nombre para que Kibana pueda consultarlos todos a la vez.


ENTITY FRAMEWORK: 
en la consola de .net

Add-Migration InitialCreate -Project Store.Data -StartupProject Store.Api -OutputDir Migrations
 
**Add-Migration** [Nombre]: Es una instrucci√≥n exclusiva para tu Proyecto .NET.

No toca Docker. No toca Postgres.

Lo que hace es leer tus clases C# y generar un archivo de historial (un archivo .cs nuevo en tu carpeta Migrations).

El nombre: Le pones el que quieras (como un mensaje de commit en Git). Se suele usar algo descriptivo como AddCategoryTable para que, si dentro de seis meses tienes 20 migraciones, sepas qu√© hizo cada una.

**Update-Database**: en la consola de .net

Update-Database -Project Store.Data -StartupProject Store.Api

Es la instrucci√≥n que ejecuta el cambio real.

Aqu√≠ .NET act√∫a como un "cliente" (como si fuera el DBeaver o el Management Studio).

Se conecta a Docker a trav√©s del puerto 5432, entra en PostgreSQL y ejecuta los CREATE TABLE o ALTER TABLE necesarios para que la base de datos coincida con tus clases de C#.


PATRONES

El Patr√≥n Unit of Work: Centralizar el DbContext y asegurar que todas las operaciones (de m√∫ltiples repositorios) se confirmen en una √∫nica transacci√≥n at√≥mica.

El Patr√≥n Repository: Encapsular toda la l√≥gica de consultas (LINQ, Include, filtros).

{
    "type": "https://tools.ietf.org/html/rfc9110#section-15.5.5",
    "title": "Not Found",
    "status": 404,
    "traceId": "00-837a6de54d20f3d83eebd2bb069b31a9-45db79335ba98653-00"
}

{
    "type": "https://tools.ietf.org/html/rfc9110#section-15.5.5",
    "title": "Not Found",
    "status": 404,
    "traceId": "00-294f4826cdc9205552ccb8be25d20b64-ad7a9c17900fd06b-00"
}

{
    "type": "https://httpstatuses.io/404",
    "title": "Recurso no encontrado",
    "status": 404,
    "detail": "The given key was not present in the dictionary.",
    "instance": "/Categories/99"
}

con docker y WSL
RabbitMQ
Redis
EntityFramework Code first
Elastic kibana
POSTGRESQL

Automapper, DDD

SNAPSHOT PARA MA√ëANA:
tree /f

Estado Actual del Sistema
Contratos (Store.Domain): Definidos como record para garantizar inmutabilidad y comparaci√≥n por valor.

Productor (Store.Api): Inyecta IPublishEndpoint para anunciar eventos (CategoryCreated) sin bloquear la respuesta al usuario.

Broker (RabbitMQ): Gestiona los Exchanges y los Bindings autom√°ticamente gracias a MassTransit.

Consumidor (Store.Worker): Proyecto independiente (Worker Service) con CategoryCreatedConsumer, configurado con NLog para enviar trazas a Elasticsearch con la etiqueta app_name: Store.Worker.

üõ†Ô∏è Gu√≠a para continuar (Paso a Paso)
Cuando est√©s listo para retomar, podemos seguir este orden. Dime en qu√© paso quieres empezar y lo desglosaremos con sus comentarios XML y mejores pr√°cticas:

Paso 1: Gesti√≥n de Resiliencia (Fault Tolerance)
Qu√© haremos: Configurar la pol√≠tica de reintentos (Retry Policy).

Instrucci√≥n: Forzaremos una Exception en el Worker para ver c√≥mo MassTransit crea la cola _error y c√≥mo podemos configurar reintentos exponenciales (esperar 5s, luego 10s, luego 30s).

Paso 2: El Patr√≥n "Outbox" (Consistencia de Datos)
Qu√© haremos: Asegurar que si la base de datos guarda la categor√≠a pero RabbitMQ est√° ca√≠do, el mensaje no se pierda.

Instrucci√≥n: Implementaremos el Transactional Outbox para que el mensaje se guarde temporalmente en SQL Server y se env√≠e solo cuando el bus est√© disponible.

Paso 3: Documentaci√≥n XML y Refactorizaci√≥n a Records
Qu√© haremos: Limpiar todos los DTOs de la API convirti√©ndolos a record y a√±adir documentaci√≥n t√©cnica profesional.

Instrucci√≥n: Usaremos comentarios /// <summary> para que Scalar/Swagger muestren una documentaci√≥n de primer nivel.

Paso 4: Dockerizaci√≥n del Ecosistema
Qu√© haremos: Actualizar el docker-compose.yml.

Instrucci√≥n: Configuraremos las redes de Docker para que la API y el Worker se vean entre s√≠ y con el contenedor de RabbitMQ usando nombres de servicio en lugar de localhost.

Tip de Pro: Recuerda siempre que el Worker debe tener el proyecto de Dominio referenciado para conocer el contrato del mensaje. ¬°Es tu "diccionario" compartido!